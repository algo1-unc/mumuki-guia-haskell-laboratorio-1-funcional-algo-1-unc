> Utilizando las funciones del ejercicio anterior, programá las siguientes funciones por composición, sin usar recursión ni análisis por casos.

>* a) `todosPares :: [Int] -> Bool` verifica que todos los números de una lista sean pares.

>* b) `hayMultiplo :: Int -> [Int] -> Bool` verifica si existe algún número dentro del
segundo parámetro que sea múltiplo del primer parámetro.

>* c) `sumaCuadrados :: Int -> Int`, dado un número no negativo n, calcula la suma de
los primeros n cuadrados, es decir 
**<Σi : 0 ≤ i < n : i²>**. Ayuda: En Haskell se puede escribir la lista que contiene el rango de números entre *n* y *m* como *[n..m]*.

>* d) ¿Se te ocurre como redefinir factorial (ej. 2d) para evitar usar recursión?

>* e) `multiplicaPares :: [Int] -> Int` que calcula el producto de todos los números pares de una lista.